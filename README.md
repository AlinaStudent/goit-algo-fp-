
# Фінальна робота: Завдання 1–7

## Запуск (Python 3.10+)
Встановіть залежності для візуалізацій:
```bash
pip install matplotlib networkx
```

---
## Завдання 1 — Однозв'язний список
Скрипт: `linked_list_tasks.py`  
Перевірка критеріїв:
- **Реверс**: `reverse_in_place()` змінює посилання між вузлами (in-place). 
- **Сортування**: `insertion_sort()` (стабільне) і опціонально `merge_sort()` (O(n log n)). 
- **Злиття**: `merge_sorted_lists(a, b)` об’єднує **відсортовані** списки. 

Запуск демо:
```bash
python linked_list_tasks.py
```

---
## Завдання 2 — Рекурсія: фрактал "дерево Піфагора"
Скрипт: `pythagoras_tree.py`  
Перевірка критеріїв:
- Код виконується і **візуалізує фрактал**. 
- Користувач задає **рівень рекурсії** флагом `--depth`. 

Приклад:
```bash
python pythagoras_tree.py --depth 11 --length 220
```

---
## Завдання 3 — Алгоритм Дейкстри (бінарна купа)
Скрипт: `dijkstra_heap.py`  
Перевірка критеріїв:
- Реалізовано **алгоритм Дейкстри** з використанням `heapq` (бінарна купа). 
- Створено граф, по якому обчислюються найкоротші шляхи від джерела. 

Запуск:
```bash
python dijkstra_heap.py
```

---
## Завдання 4 — Візуалізація бінарної купи
Скрипт: `heap_visualization.py`  
Перевірка критеріїв:
- Код виконується. 
- Функція `draw_heap_from_array(arr)` **візуалізує бінарну купу** (піраміду), задану масивом. 

Приклад (всередині скрипта вже є демо):
```bash
python heap_visualization.py
```

---
## Завдання 5 — Візуалізація обходу дерева (BFS/DFS, без рекурсії)
Скрипт: `tree_traversal_visualization.py`  
Перевірка критеріїв
- Реалізовано **BFS** (черга) та **DFS** (стек) — **без рекурсії**. 
- Вузли отримують унікальні HEX-кольори, які плавно змінюються **від темного до світлого** у порядку відвідування. 

Запуск:
```bash
python tree_traversal_visualization.py --mode bfs --pause 0.6
python tree_traversal_visualization.py --mode dfs --pause 0.6
```

---
## Завдання 6 — Жадібний алгоритм і динамічне програмування
Скрипт: `meal_selection.py`  
Перевірка критеріїв:
- `greedy_algorithm` повертає набір страв, що максимізує **calories/cost** у межах бюджету. 
- `dynamic_programming` повертає **оптимальний** набір страв при заданому бюджеті (0/1-рюкзак). 

Запуск:
```bash
python meal_selection.py
```

---
## Завдання 7 — Метод Монте-Карло (два кубики)
Скрипт: `monte_carlo_dice.py`  
Перевірка критеріїв:
- Симуляція великої кількості кидків двох кубиків, підрахунок сум і оцінка ймовірностей. 
- Побудовано **графік** із порівнянням Монте-Карло та аналітичних значень. 
- **Висновки** нижче.

Запуск (100 тис. кидків):
```bash
python monte_carlo_dice.py -n 100000
```

### Аналітичні ймовірності (2..12)
| Сума | Ймовірність |
|---:|---:|
| 2 | 2.78% |
| 3 | 5.56% |
| 4 | 8.33% |
| 5 | 11.11% |
| 6 | 13.89% |
| 7 | 16.67% |
| 8 | 13.89% |
| 9 | 11.11% |
| 10 | 8.33% |
| 11 | 5.56% |
| 12 | 2.78% |

### Висновки щодо коректності
- Емпіричні ймовірності, отримані методом Монте-Карло, **збігаються** з аналітичними в межах статистичної похибки.
- Максимальна ймовірність припадає на суму **7**, що відповідає 6 способам із 36 (≈16.67%). Сусідні суми 6 і 8 мають по 5 способів тощо — утворюючи **трикутний розподіл**.
- За збільшення кількості кидків `n` похибка **зменшується ~ O(1/√n)**, і емпіричні частоти сходяться до аналітичних значень (закон великих чисел).

---
## Файлова структура
- `linked_list_tasks.py` — список: reverse / insertion sort / merge / merge sort
- `pythagoras_tree.py` — фрактал "дерево Піфагора" з параметром глибини
- `dijkstra_heap.py` — Дейкстра з бінарною купою
- `heap_visualization.py` — візуалізація бінарної купи з масиву
- `tree_traversal_visualization.py` — BFS/DFS без рекурсії, крокова візуалізація та градієнт кольорів
- `meal_selection.py` — жадібний та DP для вибору страв
- `monte_carlo_dice.py` — Монте-Карло двох кубиків + графік порівняння
